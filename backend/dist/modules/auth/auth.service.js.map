{"version":3,"sources":["../../../src/modules/auth/auth.service.ts"],"sourcesContent":["import { Injectable, ConflictException, UnauthorizedException, BadRequestException } from '@nestjs/common';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport * as bcrypt from 'bcrypt';\r\nimport { PrismaService } from '../../prisma/prisma.service';\r\nimport { RegisterDto } from './dto/register.dto';\r\nimport { LoginDto } from './dto/login.dto';\r\nimport { ChangePasswordDto } from './dto/change-password.dto';\r\nimport { ForgotPasswordDto, ResetPasswordDto } from './dto/reset.dto';\r\nimport { OtpService } from '../otp/otp.service';\r\nimport { EmailService } from '../../common/services/email.service';\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n  constructor(\r\n    private prisma: PrismaService,\r\n    private jwtService: JwtService,\r\n    private configService: ConfigService,\r\n    private otpService: OtpService,\r\n    private emailService: EmailService,\r\n  ) { }\r\n\r\n  async register(registerDto: RegisterDto) {\r\n    // Check if user exists\r\n    const existingUser = await this.prisma.user.findFirst({\r\n      where: {\r\n        OR: [\r\n          { email: registerDto.email },\r\n          { phone: registerDto.phone },\r\n        ],\r\n      },\r\n    });\r\n\r\n    if (existingUser) {\r\n      if (existingUser.email === registerDto.email) {\r\n        throw new ConflictException('Email already registered');\r\n      }\r\n      throw new ConflictException('Phone number already registered');\r\n    }\r\n\r\n    // Hash password\r\n    const hashedPassword = await bcrypt.hash(registerDto.password, 10);\r\n\r\n    // Create user and wallet in a transaction\r\n    const user = await this.prisma.$transaction(async (tx) => {\r\n      const newUser = await tx.user.create({\r\n        data: {\r\n          email: registerDto.email,\r\n          phone: registerDto.phone,\r\n          firstName: registerDto.firstName,\r\n          lastName: registerDto.lastName,\r\n          username: registerDto.username,\r\n          accountType: registerDto.accountType || 'savings',\r\n          transactionPin: registerDto.transactionPin,\r\n          password: hashedPassword,\r\n          country: registerDto.country || 'NG',\r\n          currency: registerDto.currency || 'NGN',\r\n          role: 'USER',\r\n          accountStatus: 'PENDING', // Requires KYC approval\r\n        },\r\n        select: {\r\n          id: true,\r\n          email: true,\r\n          firstName: true,\r\n          lastName: true,\r\n          phone: true,\r\n          country: true,\r\n          currency: true,\r\n          role: true,\r\n          accountStatus: true,\r\n          isEmailVerified: true,\r\n        },\r\n      });\r\n\r\n      // Create wallet for user with user's currency\r\n      await tx.wallet.create({\r\n        data: {\r\n          userId: newUser.id,\r\n          balance: 0,\r\n          currency: registerDto.currency || 'NGN',\r\n        },\r\n      });\r\n\r\n      return newUser;\r\n    });\r\n\r\n    // Generate tokens\r\n    const tokens = await this.generateTokens(user.id, user.email, user.role);\r\n\r\n    // Send welcome email (non-blocking)\r\n    try {\r\n      await this.emailService.sendWelcomeEmail({\r\n        email: user.email,\r\n        firstName: user.firstName,\r\n        lastName: user.lastName,\r\n        accountNumber: '****' // replace with real if available\r\n      });\r\n    } catch { }\r\n\r\n    return {\r\n      user,\r\n      ...tokens,\r\n    };\r\n  }\r\n\r\n  async login(loginDto: LoginDto) {\r\n    // Find user\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { email: loginDto.email },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new UnauthorizedException('Invalid credentials');\r\n    }\r\n\r\n    // Verify password\r\n    const isPasswordValid = await bcrypt.compare(loginDto.password, user.password);\r\n    if (!isPasswordValid) {\r\n      throw new UnauthorizedException('Invalid credentials');\r\n    }\r\n\r\n    // Only block CLOSED and FROZEN accounts from logging in\r\n    // SUSPENDED accounts can log in but with limited access\r\n    if (user.accountStatus === 'CLOSED' || user.accountStatus === 'FROZEN') {\r\n      throw new UnauthorizedException(`Account is ${user.accountStatus.toLowerCase()}. Please contact support.`);\r\n    }\r\n\r\n    // Update last login\r\n    await this.prisma.user.update({\r\n      where: { id: user.id },\r\n      data: { lastLoginAt: new Date() },\r\n    });\r\n\r\n    // Generate tokens\r\n    const tokens = await this.generateTokens(user.id, user.email, user.role);\r\n\r\n    return {\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        firstName: user.firstName,\r\n        lastName: user.lastName,\r\n        phone: user.phone,\r\n        country: user.country,\r\n        currency: user.currency,\r\n        role: user.role,\r\n        accountStatus: user.accountStatus,\r\n        isEmailVerified: user.isEmailVerified,\r\n      },\r\n      ...tokens,\r\n    };\r\n  }\r\n\r\n  async refreshToken(refreshToken: string) {\r\n    try {\r\n      const payload = this.jwtService.verify(refreshToken, {\r\n        secret: this.configService.get<string>('JWT_REFRESH_SECRET'),\r\n      });\r\n\r\n      const user = await this.prisma.user.findUnique({\r\n        where: { id: payload.sub },\r\n      });\r\n\r\n      if (!user) {\r\n        throw new UnauthorizedException('User not found');\r\n      }\r\n\r\n      return this.generateTokens(user.id, user.email, user.role);\r\n    } catch (error) {\r\n      throw new UnauthorizedException('Invalid refresh token');\r\n    }\r\n  }\r\n\r\n  async validateUser(userId: string) {\r\n    return this.prisma.user.findUnique({\r\n      where: { id: userId },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        firstName: true,\r\n        lastName: true,\r\n        phone: true,\r\n        country: true,\r\n        currency: true,\r\n        role: true,\r\n        accountStatus: true,\r\n        isEmailVerified: true,\r\n        wallet: {\r\n          select: {\r\n            balance: true,\r\n            currency: true,\r\n          },\r\n        },\r\n        kyc: {\r\n          select: {\r\n            status: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n  }\r\n\r\n  async changePassword(userId: string, changePasswordDto: ChangePasswordDto) {\r\n    // Validate passwords match\r\n    if (changePasswordDto.newPassword !== changePasswordDto.confirmPassword) {\r\n      throw new BadRequestException('New passwords do not match');\r\n    }\r\n\r\n    // Get user with password\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { id: userId },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new UnauthorizedException('User not found');\r\n    }\r\n\r\n    // Verify current password\r\n    const isPasswordValid = await bcrypt.compare(\r\n      changePasswordDto.currentPassword,\r\n      user.password,\r\n    );\r\n\r\n    if (!isPasswordValid) {\r\n      throw new UnauthorizedException('Current password is incorrect');\r\n    }\r\n\r\n    // Check if new password is same as current\r\n    const isSamePassword = await bcrypt.compare(\r\n      changePasswordDto.newPassword,\r\n      user.password,\r\n    );\r\n\r\n    if (isSamePassword) {\r\n      throw new BadRequestException('New password must be different from current password');\r\n    }\r\n\r\n    // Hash new password\r\n    const hashedPassword = await bcrypt.hash(changePasswordDto.newPassword, 10);\r\n\r\n    // Update password\r\n    await this.prisma.user.update({\r\n      where: { id: userId },\r\n      data: { password: hashedPassword },\r\n    });\r\n\r\n    return { message: 'Password changed successfully' };\r\n  }\r\n\r\n  async forgotPassword(dto: ForgotPasswordDto) {\r\n    const user = await this.prisma.user.findUnique({ where: { email: dto.email } });\r\n    if (!user) {\r\n      // Avoid user enumeration\r\n      return { message: 'If that email exists, a reset code has been sent.' };\r\n    }\r\n\r\n    try {\r\n      const start = await this.otpService.start(user.id, 'RESET', {\r\n        email: user.email,\r\n        firstName: user.firstName,\r\n      });\r\n\r\n      const resetUrl = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password?email=${encodeURIComponent(user.email)}&otpId=${encodeURIComponent(start.otpId)}`;\r\n      try {\r\n        await this.emailService.sendPasswordResetEmail({ email: user.email, firstName: user.firstName, resetUrl });\r\n      } catch (emailError) {\r\n        console.error('Failed to send password reset email:', emailError);\r\n      }\r\n      return { message: 'If that email exists, a reset code has been sent.', otpId: start.otpId, expiresIn: start.expiresIn };\r\n    } catch (error) {\r\n      console.error('Forgot password error:', error);\r\n      throw new BadRequestException('Failed to process password reset request');\r\n    }\r\n  }\r\n\r\n  async resetPassword(dto: ResetPasswordDto) {\r\n    const otp = await (this.prisma as any).otpCode.findUnique({ where: { id: dto.otpId } });\r\n    if (!otp) throw new BadRequestException('Invalid or expired code');\r\n    await this.otpService.verify(otp.userId, dto.otpId, dto.code);\r\n\r\n    // Get user's current password to check for reuse\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { id: otp.userId },\r\n      select: { password: true },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new BadRequestException('User not found');\r\n    }\r\n\r\n    // Check if new password is same as current password\r\n    const isSamePassword = await bcrypt.compare(dto.newPassword, user.password);\r\n    if (isSamePassword) {\r\n      throw new BadRequestException('New password must be different from your current password');\r\n    }\r\n\r\n    const hashed = await bcrypt.hash(dto.newPassword, 10);\r\n    await this.prisma.user.update({ where: { id: otp.userId }, data: { password: hashed } });\r\n    return { message: 'Password reset successful' };\r\n  }\r\n\r\n  async getUserSettings(userId: string) {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { id: userId },\r\n      select: {\r\n        emailTransactions: true,\r\n        emailSecurity: true,\r\n        emailMarketing: true,\r\n        smsTransactions: true,\r\n        smsSecurity: true,\r\n        pushNotifications: true,\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new UnauthorizedException('User not found');\r\n    }\r\n\r\n    return user;\r\n  }\r\n\r\n  async updateUserSettings(\r\n    userId: string,\r\n    settings: {\r\n      emailTransactions?: boolean;\r\n      emailSecurity?: boolean;\r\n      emailMarketing?: boolean;\r\n      smsTransactions?: boolean;\r\n      smsSecurity?: boolean;\r\n      pushNotifications?: boolean;\r\n    },\r\n  ) {\r\n    const updatedUser = await this.prisma.user.update({\r\n      where: { id: userId },\r\n      data: settings,\r\n      select: {\r\n        emailTransactions: true,\r\n        emailSecurity: true,\r\n        emailMarketing: true,\r\n        smsTransactions: true,\r\n        smsSecurity: true,\r\n        pushNotifications: true,\r\n      },\r\n    });\r\n\r\n    return {\r\n      message: 'Settings updated successfully',\r\n      settings: updatedUser,\r\n    };\r\n  }\r\n\r\n  async sendVerificationEmail(userId: string) {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { id: userId },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        firstName: true,\r\n        isEmailVerified: true,\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new UnauthorizedException('User not found');\r\n    }\r\n\r\n    if (user.isEmailVerified) {\r\n      throw new BadRequestException('Email is already verified');\r\n    }\r\n\r\n    // Generate OTP\r\n    const start = await this.otpService.start(user.id, 'EMAIL_VERIFICATION', {\r\n      email: user.email,\r\n      firstName: user.firstName,\r\n    });\r\n\r\n    // Send verification email with OTP\r\n    try {\r\n      await this.emailService.sendGenericNotification({\r\n        email: user.email,\r\n        title: 'ðŸ“§ Verify Your Email Address',\r\n        message: `Hi ${user.firstName},<br><br>Thank you for registering! Please use the verification code below to confirm your email address:<br><br><div style=\"background:#f8fafc;padding:24px;border-radius:8px;text-align:center;margin:24px 0\"><span style=\"font-size:32px;font-weight:bold;letter-spacing:8px;color:#1e293b\">${start.code}</span></div><br>This code will expire in <strong>${Math.floor(start.expiresIn / 60)} minutes</strong>.<br><br>If you didn't request this verification, please ignore this email.`,\r\n        actionLabel: 'Verify Email',\r\n        actionUrl: `${process.env.FRONTEND_URL || 'http://localhost:3000'}/user/profile`,\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to send verification email:', error);\r\n    }\r\n\r\n    return {\r\n      message: 'Verification code sent to your email',\r\n      otpId: start.otpId,\r\n      expiresIn: start.expiresIn,\r\n    };\r\n  }\r\n\r\n  async verifyEmail(userId: string, otpId: string, code: string) {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: { id: userId },\r\n      select: { id: true, isEmailVerified: true },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new UnauthorizedException('User not found');\r\n    }\r\n\r\n    if (user.isEmailVerified) {\r\n      throw new BadRequestException('Email is already verified');\r\n    }\r\n\r\n    // Verify OTP code\r\n    await this.otpService.verify(userId, otpId, code);\r\n\r\n    // Update user email verification status\r\n    await this.prisma.user.update({\r\n      where: { id: userId },\r\n      data: { isEmailVerified: true },\r\n    });\r\n\r\n    return { message: 'Email verified successfully' };\r\n  }\r\n\r\n  private async generateTokens(userId: string, email: string, role: string) {\r\n    const payload = { sub: userId, email, role };\r\n\r\n    const [accessToken, refreshToken] = await Promise.all([\r\n      this.jwtService.signAsync(payload, {\r\n        secret: this.configService.get<string>('JWT_SECRET') || 'default-secret',\r\n        expiresIn: '7d',\r\n      }),\r\n      this.jwtService.signAsync(payload, {\r\n        secret: this.configService.get<string>('JWT_REFRESH_SECRET') || 'default-refresh-secret',\r\n        expiresIn: '30d',\r\n      }),\r\n    ]);\r\n\r\n    return {\r\n      accessToken,\r\n      refreshToken,\r\n    };\r\n  }\r\n}\r\n"],"names":["AuthService","register","registerDto","existingUser","prisma","user","findFirst","where","OR","email","phone","ConflictException","hashedPassword","bcrypt","hash","password","$transaction","tx","newUser","create","data","firstName","lastName","username","accountType","transactionPin","country","currency","role","accountStatus","select","id","isEmailVerified","wallet","userId","balance","tokens","generateTokens","emailService","sendWelcomeEmail","accountNumber","login","loginDto","findUnique","UnauthorizedException","isPasswordValid","compare","toLowerCase","update","lastLoginAt","Date","refreshToken","payload","jwtService","verify","secret","configService","get","sub","error","validateUser","kyc","status","changePassword","changePasswordDto","newPassword","confirmPassword","BadRequestException","currentPassword","isSamePassword","message","forgotPassword","dto","start","otpService","resetUrl","process","env","FRONTEND_URL","encodeURIComponent","otpId","sendPasswordResetEmail","emailError","console","expiresIn","resetPassword","otp","otpCode","code","hashed","getUserSettings","emailTransactions","emailSecurity","emailMarketing","smsTransactions","smsSecurity","pushNotifications","updateUserSettings","settings","updatedUser","sendVerificationEmail","sendGenericNotification","title","Math","floor","actionLabel","actionUrl","verifyEmail","accessToken","Promise","all","signAsync"],"mappings":"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"}